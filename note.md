2024.04.12，感觉回溯有点难，虽然算法框架简单，但变种有点难
2024.04.13，从LC22学到两个提升性能的技巧：
            1.结果数组中的元素是字符串的回溯，将track的类型由链表改为stringbuilder，可提升性能，因为最后链表需要join("",track)，而stringbuilder直接tostring即可；
            2.删除最后一个字符这里用setLength方法，总用时由1ms将为0ms，因为setLength方法不用像deleteCharAt方法那样需要遍历并挪动字符
2024.04.16, 子集，元素不重复，不可复选，用start控制元素相对位置            ，关键字，start
            子集，组合，元素可重复，不可复选，先排序，再跳过值相同的元素      ，关键字，sort
            排列，元素不重复，不可复选，用used数组记录已用过的元素         , 关键字，used，排列！
            排列，元素重复，不可复选，用used数组记录已用过的元素+sort再剪枝！        , 关键字，used，排列！+sort剪枝
            （从这里可以看到，只要元素可重复，就用sort剪枝！）
2024.04.17，回溯解决组合/子集，排列问题：
			1.元素不重复，不可复选，组合子集：用start控制；排列：用used控制
			2.元素可重复，不可复选，组合子集：start控制 + sort再剪枝； 排列：used控制 + sort再剪枝，注意剪枝时要判断！used(i-1)->continue
			3.元素不重复，可以复选，组合子集：用start控制，且下一次从i开始，而不是i+1；排列：不used，不sort

2024.05.14，滑动窗口的框架：
    1.先将target读入map
    need 存target
    window 存s
    while(right<t.size()){
    
    如果右指针指向的字符在need存在，设置window，并更新valid
        如果valid==need.size(),开始收缩窗口，
            先判断最小长度是否需要更新，再判断valid是否需要更新，再更新window
    
    }
（感觉这么写框架没多大用，还是直接看代码吧）

2024.05.18,LC23. 合并 K 个升序链表
//注意new 后面的尖括号别落下
PriorityQueue<ListNode> queue = new PriorityQueue<>(lists.length, (a,b)->(a.val-b.val));


2024.05.24, LC92,反转链表II，
//前进到第left个节点的方式，值得记忆！
head.next = reverseBetween(head.next, left-1,right-1);

2024.05.24，LC25, K 个一组翻转链表
// 哈哈我踏马真是做一次就在这里踩坑一次，如果翻转整个链表，结束条件才是!=null，现在是翻转区间，就要!=b
while(current!=b){

2024.05.28, LC19，打印倒数第k个链表节点，是个很基础的东西！记住count++要放在递归之后，参考二叉树的后续遍历
2024.05.28,LC82,删除重复节点，还是没能写出来，记住一点，移动完，slow不能和fast指向同一个节点。fast要先去前面探路，所以移动时要等slow移动完，再移动，这样能保持领先
2024.05.29,LC103,//唉！恍然大悟！记住LinkedList有方法可以头插或者尾插！自然就可以控制方向了

2024.05.31，LC236,//就是去左右子树中找p或q,找到了p或q，说明当前节点有可能是所求，如果左右子树都找到了，说明当前节点就是所求
//诀窍就是搞清楚递归函数的定义，不要去想递归起来以后的细节！否则就是庸人自扰！

2024.06.03，LC124,这里为什么在小于0时要返回0，而不是直接返回outMax?为了让贡献值为负的节点不影响整个路径的最大和。那怎么做到不影响呢，就在本层递归直接返回0，那在此次递归的外层，会加0，就相当于什么也没加，就相当于没影响到最大路径和了

2024.06.04,LC105,注意！根节点的值要写成preorder[preStart]，而不是preorder[0]!因为子树的根节点在变，不固定！

2024.06.07,LC124和LC543可以一起看，都是典型的分解递归思路

2024.06.07,LC662，二叉树最大宽度，再练练吧，细节挺有意思的，虽然没啥技巧可言

2024.06.12,LC162寻找峰值，判断mid和left，right的大小关系太复杂，上面就是反例，关键思路是换个角度，判断mid和mid+1的大小关系

2024.06.13，LC146，LRU，我觉得很重要，只要记住一点，要用到linkedhashmap

2024.06.17.LC5，最长回文字串，记住双指针，然后从中心向两边扩散

2024.06.18,LC215,数组中第k大元素，记住用优先级队列即可

2024.06.18,LC415,字符串相加，技巧：获得char类型的数字对应的int值，char-'0'

2024.06.19,LC25,K个一组翻转链表，记住1.迭代方式的翻转链表，是节点两个两个地翻转，不要一次想翻转3个节点，然后是，2.最后返回previous节点